
# 観点

- ステップバイステップの解説
- 概念ごとの解説
- 哲学の解説

生成されるコードをわざわざ見せるのはやめて、動作の解説にとどめることにしたい。
そうすることで、生成されるコードが多少キモくてもドキュメントはきれいになる

# 概念

- ファクトリークラス
- リゾルバーメソッド 、 マルチリゾルバーメソッド
- 依存関係の解決
- ファクトリーの委譲
- ファクトリーの継承
- 依存関係の解決手段
- キャッシュ
- フック
- IDisposable
- ResolverService
- Resolution属性

## ファクトリークラス

ファクトリークラスとは、以下の性質を満たすクラス。

- partialクラスである
- Factory属性がついている

ファクトリークラスのことを単にファクトリーとも呼ぶ。

Imfactはファクトリークラスに対して、もう一方のpartial定義を生成する。
その定義内には、リゾルバーメソッドなどファクトリークラスに必要な実装が含まれる。

## リゾルバーメソッド

リゾルバーメソッドとは、以下の性質を満たすクラス。

- partialメソッドである
- ファクトリークラスに属するメソッドである

生成された側のファクトリー定義には、リゾルバーメソッドの実装が生成される。
リゾルバーはこの実装によって、求めるオブジェクトの依存関係を解決する。

戻り値の型と同じ型のインスタンスを生成するのがリゾルバーの役目である。
ただし、Resolution属性がついていれば代わりにそちらで指定された型を生成する。

パラメータを持つこともでき、インスタンスを生成するために必要に応じて引数の値を使用する。

戻り値の型が IEnumerable であるようなリゾルバーを、マルチリゾルバーという。

## 依存関係の解決

クラスはコンストラクタを通じてオブジェクトを要求することがある。
クラスAのコンストラクタでクラスBのオブジェクトが要求されるとき、
AはBに依存しているという。
こういった場合、Aを生成するためにはBのオブジェクトが必須となる。

そして実際にはAが他のオブジェクトC,Dにも依存していたり、
BもまたC,E,Fなどといったオブジェクトに依存していたりして、
依存関係の複雑なネットワークが生じる場合がある。

こういったネットワークを持つオブジェクトを生成するコードを手で書くことは煩雑であるので、
Imfactがそういったコードを生成する。

依存関係の条件を満たしてオブジェクトを生成するコードを構築することを、
依存関係を解決する、と言うことにする。

リゾルバーは、要求された型のコンストラクタや、他のリゾルバーを呼び出すことによって
依存先のオブジェクトを収集し、要求された型のオブジェクトを生成する。

## ファクトリーの委譲

あるファクトリーAが別のファクトリーBをプロパティとして保持しているとき、
ファクトリーAは自身が依存関係の解決を行う際に、
オブジェクトの生成の一部または全部をファクトリーBのリゾルバーを呼び出すことで達成する。

これを、ファクトリーAがファクトリーBに処理を委譲するという。

オブジェクト指向でいう通常の意味での委譲と同様で、
委譲先のファクトリーのpublic,internalなリゾルバーのみを呼び出すことができる。

ファクトリーの委譲では、委譲先のファクトリーの持つリゾルバーではないメソッドも候補に選ばれる。
これを利用してオブジェクトの生成方法を自由に差し込むこともできる。

## ファクトリーの継承

あるファクトリーAが別のファクトリーBを継承しているとき、
ファクトリーAは自身が依存関係の解決を行う際に、
オブジェクトの生成の一部または全部をファクトリーBのリゾルバーを呼び出すことで達成する。

オブジェクト指向でいう通常の意味での継承と同様で、
委譲先のファクトリーのpublic,internal,protectedまたは
それに準ずるアクセスレベルのリゾルバーのみを呼び出すことができる。



## 依存関係の解決手段

依存関係の解決に使われる手段はコンストラクタ呼び出しだけではない。
以下のような方法を組み合わせて、リゾルバーはオブジェクトの生成に必要なオブジェクトを収集する。

- パラメータ
- 委譲したファクトリーそのもの
- ファクトリー自身
- 委譲したファクトリーのリゾルバー
- 自分自身のリゾルバー
- 継承したファクトリーのリゾルバー
- コンストラクタ

もし以上の方法で解決できないオブジェクトに依存している場合、
依存先のオブジェクトはファクトリーのコンストラクタを通じて要求され、
依存先のオブジェクトを利用側が補わなければファクトリーを使えなくなる。

## キャッシュ

特に何も指定しない場合、リゾルバーは呼び出されるたびに新たなオブジェクトを生成する。
生成に時間のかかるようなオブジェクトであったり、
常に同一のオブジェクトを返してほしい場合にはこの方法は都合が悪い。

そこで、`Cache`属性をリゾルバーに付与することで生成したオブジェクトをキャッシュすることができる。
オブジェクトがキャッシュされていると、リゾルバーは呼ばれるたびにキャッシュからオブジェクトを返すことで、
コンストラクタ呼び出しなどの重い可能性がある処理を飛ばすことができる。

あるいは、あるオブジェクトの生成中に別の特定のオブジェクトXが複数回要求されることがあるかもしれない。
その場合に`Cache`を使うとオブジェクトXは1回だけしか生成されずに済むのだが、
リゾルバーを呼び出すたびに同じオブジェクトXが使われてしまうのは都合が悪いこともある。

その場合は`CachePerResolution`属性を使うことができる。
この属性がついたリゾルバーは、依存関係の解決１回につき１度しかオブジェクトの生成を行わず、
２回目以降の要求ではキャッシュを返す。
しかも、依存関係の解決が完了すれば、次に来る要求ではまた新しいオブジェクトを返す。

## フック

依存関係を解決する処理の前後に何らかの処理を挟むことができる機能である。
`IHook`インタフェースを実装することで作成できる。
こうして作成したフックは、`Hook`属性の引数に与えることでファクトリークラスから利用される。

もしリゾルバーに要求されたインスタンスを`Before`メソッドから返したなら、
リゾルバーの実行はそこで終了し、返されたインスタンスがリゾルバーの結果となる。
リゾルバーの実行が終了する前に`After`メソッドが呼ばれる。
`Before`メソッドが呼ばれなかったフックに対しては、`After`メソッドも呼ばれない。

`Cache`, `CachePerResolution` もフックによって実現されている。

## ResolverService



## Resolution属性



# ステップバイステップ

その１　基本的な使い方

- ファクトリーを作ってみる
- 依存関係のあるオブジェクトを生成させる
- オブジェクトをキャッシュさせる

その２　リゾルバーを使いこなす

- Resolution属性で具体的な型を与える
- リゾルバーのアクセスレベルを変えてみる
- リゾルバーに引数を与える
- マルチリゾルバー

その２　モジュール性

- ファクトリーを委譲する
- ファクトリーを継承する
- 依存関係の解決手段と優先順位

その３　便利な使い方

- フックを作ってみる
- IDisposableなオブジェクト

# 書く場所

- Zenn記事
- GitHubマニュアル

