
# 機能リファレンス

ここでは、Imfactの持つ機能や概念の解説をします。

- [ファクトリークラス](#factory)
- [リゾルバーメソッド](#resolver)
- [依存関係の解決](#dependency)
- [ファクトリーの委譲](#delegation)
- [ファクトリーの継承](#inheritance)
- [依存関係の解決手段](#strategy)
- [キャッシュ](#cache)
- [フック](#hook)

<a id="factory"></a>

## ファクトリークラス

以下の性質を満たすクラスのことを、ファクトリークラスと呼びます。単にファクトリーとも呼びます。

- partialクラスである
- Imfact.Annotations.Factory属性がついている

Imfactはファクトリークラスに対して、もうひとつのpartial定義を生成します。その定義の中には、リゾルバーメソッドの実装などが含まれます。

<a id="resolver"></a>

## リゾルバーメソッド

以下の性質を満たすメソッドのことを、リゾルバーメソッドと呼びます。単にリゾルバーとも呼びます。

- partialメソッドである
- ファクトリークラスに属するメソッドである

リゾルバーメソッドの役目は、その戻り値の型と同じ型のインスタンスを生成することです。もし戻り値の型が別の型に依存しているならば、そういった依存先も全て生成しながら、目的のインスタンスの生成まで至ります。（「依存している」という言葉については次の節で解説します。）

リゾルバーはパラメータを持つこともできます。依存関係を解決していく中で必要になった型が引数として渡されている場合、リゾルバーは優先的に引数の値を使用します。このとき、それぞれの引数は1回しか使われません。

上述の通り、リゾルバーは基本的に戻り値の型と同じ型のインスタンスを生成しますが、Resolution属性を使うことによって、戻り値の型の派生型を生成させることもできます。

それから、戻り値の型が IEnumerable であるようなリゾルバーメソッドを、マルチリゾルバーメソッドと呼びます。

リゾルバーがインスタンスを生成するために用いる基本的な手段は、コンストラクタを呼び出すことです。しかし、依存関係を解決する際には他の手段も多用します。詳しくは後の節で解説します。

<a id="dependency"></a>

## 依存関係の解決

「あるクラスAがあるクラスBに依存している」とは、クラスBをパラメータとして要求するようなコンストラクタをクラスAが持っている状態のことをいいます。

```csharp
// このClassAは、ClassBをパラメータとして要求するような
// コンストラクタを持っているので、ClassBに依存していると言う
class ClassA
{
    public ClassA(ClassB b)
    {
    }
}

class ClassB
{
}
```

「クラスAの依存関係を解決する」とは、クラスAのコンストラクタを呼び出すために必要なインスタンスを全て生成することを言います。また、「クラスAの依存関係を解決してインスタンスを生成する」とは、クラスAの依存関係を解決してもって、クラスAを生成することに成功することを言います。

現実のソースコードでは、ひとつのクラスが多数のクラスへ依存したり、多数のクラスがひとつのクラスへ依存したりなど複雑な依存関係のネットワークを持つことがあります。そういった依存関係を満たしてインスタンスを生成するようなコードを書くのは、しばしば煩雑になります。そこで、Imfactはインスタンスを生成するための煩雑なコードを自動生成してくれます。

<a id="delegation"></a>

## ファクトリーの委譲

あるファクトリーAに、別のファクトリーBをプロパティとして保持させると、ファクトリーAに属するリゾルバーが依存関係の解決を行う際に、依存先である各インスタンスを生成するための手段として、ファクトリーBの持つメソッドを呼び出す方法が候補に入るようになります。

これを「ファクトリーAがファクトリーBに処理を委譲している」と言います。

委譲先のファクトリーが持つメソッドを呼び出すことでインスタンスを生成しますが、通常の委譲と同様で、 public, internal なメソッドのみが使用されます。

ファクトリーの委譲では、委譲先のファクトリーが持つリゾルバーではないメソッドも候補に選ばれるので、これを利用してオブジェクトの生成方法を自由にカスタマイズすることもできます。

<a id="inheritance"></a>

## ファクトリーの継承

あるファクトリーAが別のファクトリーBを継承していると、ファクトリーAに属するリゾルバーが依存関係の解決を行う際に、依存先である各インスタンスを生成するための手段として、ファクトリーBの持つメソッドを呼び出す方法が候補に入るようになります。

これを「ファクトリーAがファクトリーBを継承している」と言います。

基底クラスが持つメソッドを呼び出すことでインスタンスを生成しますが、通常の継承と同様で、 public, internal, protected, protected internal, private protected なメソッドのみが使用されます。

<a id="strategy"></a>

## 依存関係の解決手段

リゾルバーは要求されたインスタンスを生成したり、依存関係を解決するために様々な方法を組み合わせます。それは以下のとおりです。

- パラメータの型が一致すれば、それを使う
- 委譲したファクトリーの型が一致すれば、そのプロパティからgetする
- ファクトリー自身の型が一致すれば、thisを使う
- 委譲したファクトリーのリゾルバー
- ファクトリー自身のリゾルバー（ただし、再帰呼び出しは避ける）
- 継承したファクトリーのリゾルバー
- コンストラクタ（リゾルバーの戻り値の型である場合のみ）

もし、リゾルバーが依存関係を委譲の方法で解決できない場合、依存先のオブジェクトはファクトリーのコンストラクタを通じて要求されます。依存先のオブジェクトを利用側が補わなければコンパイルエラーとなるので、ファクトリーを使えません。

依存関係を解決できない場合にコンパイルエラーとなることで、コードの問題を早い段階で発見することができるのもImfactの強みです。ファクトリークラスのコンストラクタに意外な引数が要求されてしまったら、リゾルバーの定義などが欠けていないか確認してみましょう。

<a id="cache"></a>

## キャッシュ

リゾルバーの定義に`Cache`属性をつけることで、リゾルバーの生成するインスタンスをキャッシュすることができます。属性を付けなければ、リゾルバーは呼び出すたびに新しいインスタンスを生成します。

キャッシュをするリゾルバーは、何度呼び出しても同一のインスタンスを返すため、生成に時間のかかるインスタンスや、常に同一のものをシングルトン的に使いたいようなインスタンスを生成させたい場合に便利です。また、依存関係を解決する過程で呼ばれたリゾルバーも、キャッシュの指定があればキャッシュを行います。

また、`CachePerResolution`属性をつけたリゾルバーは、依存関係の解決1回につき1度だけインスタンスの生成を行います。あるクラスXのインスタンスを生成するとき、依存先のインスタンスは複数回要求されても同一のインスタンスを返したいが、もう一度クラスXのインスタンスを新しく生成するときには依存先のインスタンスも新しく生成してほしい……といった場合に役立ちます。

<a id="hook"></a>

## フック

フックは、リゾルバーの処理の前後に何か別の処理を挟むことができる機能です。この処理はユーザーが自作することができ、リゾルバーが呼ばれる前後にログを仕込むなどのカスタマイズができます。

フックを作るには、`IHook`インターフェースを実装したクラスを作成します。そして任意のリゾルバーに`Hook`属性をつけ、その属性引数として自作したフックの型を与えることでリゾルバーから利用されるようになります。

フックは`Before`, `After`, `RegisterService`メソッドを持ちます。

`Before`メソッドは、リゾルバーに代わってインスタンスを生成しても構いません。生成したインスタンスを返すと、リゾルバーの処理はそこで打ち切られ、フック群の`After`が呼ばれたのちリゾルバーの処理が終了します。

`After`メソッドには、生成されたインスタンスが渡されてきます。`After`メソッドはこれを別のインスタンスにすり替えても構いません。それから重要なポイントとして、`Before`メソッドが呼ばれなかったフックに対しては、`After`メソッドも呼ばれません。

ちなみに、`Cache`と`CachePerResolution`の処理もフックを利用して実現されています。
