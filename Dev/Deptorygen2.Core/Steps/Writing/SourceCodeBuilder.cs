using System.Linq;
using Deptorygen2.Core.Steps.Creation.Abstraction;
using Deptorygen2.Core.Steps.Definitions;
using NacHelpers.Extensions;

namespace Deptorygen2.Core.Steps.Writing
{
	internal class SourceCodeBuilder
	{
		private readonly DefinitionRoot _definitionRoot;
		private readonly ICreationAggregator _creation;
		private readonly ResolverWriter _resolverWriter;

		public SourceCodeBuilder(SourceTreeDefinition definition)
		{
			_definitionRoot = definition.DefinitionRoot;
			_creation = definition.Creation;
			_resolverWriter = new ResolverWriter();
		}

		public SourceFile Write()
		{
			var fileName = _definitionRoot.Namespace.Class.Name + ".g";
			var contents = Render();
			return new SourceFile(fileName, contents);
		}

		private string Render()
		{
			var builder = CodeHelper.GetBuilder();

			builder.AppendLine("// <autogenerated />");
			builder.AppendLine("#nullable enable");

			foreach (var usingNode in _definitionRoot.Usings)
			{
				builder.AppendLine($"using {usingNode.Namespace};");
			}

			builder.AppendLine();

			builder.AppendLine($"namespace {_definitionRoot.Namespace.Name}");
			builder.EnterBlock(inner =>
			{
				RenderClass(_definitionRoot.Namespace.Class, inner);
			});

			return builder.GetText();
		}

		private void RenderClass(Class @class, ICodeBuilder builder)
		{
			builder.AppendLine($"partial class {@class.Name}");
			builder.EnterBlock(block =>
			{
				block.EnterSequence(seqOuter =>
				{
					seqOuter.EnterChunk(chunk =>
					{
						foreach (var field in @class.Fields)
						{
							chunk.AppendLine($"private readonly {field.Type.Text} {field.Name};");
						}
					});

					seqOuter.EnterChunk(chunk => RenderConstructor(@class.Constructor, chunk));

					seqOuter.EnterSequenceChunk(@class.EntryMethods, (method, inner) =>
						RenderEntryMethod(method, inner));

					seqOuter.EnterSequenceChunk(@class.Methods, (method, inner) =>
						RenderMethod(method, inner));

					seqOuter.EnterSequenceChunk(@class.EnumMethods, (method, inner) =>
						RenderEnumerableMethod(method, inner));
				});
			});
		}

		private void RenderMethod(Method method, ICodeBuilder builder)
		{
			var paramList = method.Parameters
				.Select(x => $"{x.Type.Text} {x.Name}")
				.Join(", ");
			
			var ret = method.ReturnType.Text;

			builder.EnterChunk(chunk =>
			{
				chunk.AppendLine("[EditorBrowsable(EditorBrowsableState.Never)]");
				chunk.AppendLine($"internal {ret} {method.Name}({paramList})");
				chunk.EnterBlock(block =>
				{
					_resolverWriter.RenderImplementation(method, _creation, block);
				});
			});
		}

		private void RenderEnumerableMethod(EnumMethod method, ICodeBuilder builder)
		{
			var paramList = method.Parameters
				.Select(x => $"{x.Type.Text} {x.Name}")
				.Join(", ");

			var ret = $"IEnumerable<{method.ElementType.Text}>";

			builder.EnterChunk(chunk =>
			{
				chunk.AppendLine("[EditorBrowsable(EditorBrowsableState.Never)]");
				chunk.AppendLine($"internal {ret} {method.Name}({paramList})");
				chunk.EnterBlock(inner =>
				{
					_resolverWriter.RenderImplementation(method, _creation, inner);
				});
			});
		}

		private void RenderConstructor(Constructor ctor, ICodeBuilder builder)
		{
			var paramList = ctor.Parameters
				.Select(x => $"{x.Type.Text} {x.Name}")
				.Join(", ");
			var access = ctor.Accessibility.ToString().ToLower();

			builder.EnterChunk(chunk =>
			{
				chunk.AppendLine($"{access} {ctor.Name}({paramList})");
				chunk.EnterBlock(block =>
				{
					foreach (var assignment in ctor.Assignments)
					{
						block.AppendLine($"{assignment.Dest} = {assignment.Src};");
					}
				});
			});
		}

		private void RenderEntryMethod(EntryMethod method, ICodeBuilder builder)
		{
			var paramList = method.Parameters
				.Select(x => $"{x.Type.Text} {x.Name}")
				.Join(", ");
			var argList = method.Parameters
				.Select(x => x.Name)
				.Append("context")
				.Join(", ");

			var access = method.Accessibility.ToString().ToLower();
			var ret = method.ReturnType.Text;

			builder.EnterChunk(chunk =>
			{
				chunk.AppendLine($"{access} partial {ret} {method.Name}({paramList})");
				chunk.EnterBlock(block =>
				{
					block.AppendLine("var context = new ResolutionContext();");
					block.AppendLine($"return __{method.Name}({argList});");
				});
			});
		}
	}
}
