
継承をサポートするために最後の対応が必要。
派生クラスのコンストラクタは、基底クラスのコンストラクタ引数を与えなければならない。
これは非常に難しい。コードは複雑になるし実行時間も伸びる。

簡単にするには、基底ファクトリーが生成された後で派生ファクトリーを生成する必要がある。
そうすれば、基底ファクトリーのコンストラクタを見れば与えるべき依存先を見つけることができる。

継承はリニアなので、順番を調べるのは難しくはなさそう。ファクトリーの一覧を手に入れたら、
何も継承していないファクトリーを集めて、ランク０とする。
それを継承しているファクトリーはランク１。
ランク１を継承しているファクトリーはランク２。以後同様。
ある程度以上のランクに達したらエラーとした方がいいかもしれない。


対応は数ステップに分かれる。
- 継承階層からランク分けを決める。
- ランク順にファクトリークラスを生成する。
	- 生成時、自分より低ランクのファクトリーの持つコンストラクタを参照することができる。

たぶんランクに分けた生成とコンストラクタの生成はできるようになった。
しかし、生成したファクトリーを逐次モデルに追加していかないと、生成されたメンバーなどを取得できなさそう。
モデルに追加するには、途中でコンパイルを挟まないといけないが、実行コストも設計コストも高そう……
IAnalysisContext に、各ランクでのコンストラクタ引数の情報を追記していく方がマシかな

キャプチャされたリゾルバーに対する引数が依存関係にカウントされていないため、
そういったリゾルバーに依存するリゾルバーが解決できなくなってしまっている。
このようなリゾルバーに対しては依存元のほうにフィールドを持たせる必要がある。

引数のうち、メソッドのパラメータでもって解決できるものを除外したいが、どうすればいい？
Definition辺りに解決のステップを作ってしまって、解決結果をDefinitionに含めて、
そこで解決できなかったものをフィールドとして生成してしまうほうが簡単そう

Creation部分のリファクタリングが必要そう。


Rankingステップ
Aspectステップ
Semanticsステップ
Dependencyステップ
Definitionステップ
Writingステップ

---

記事化できる知識が溜まってきた。

- NerdBank.GitVersioningでバージョン管理
- SyntaxとSymbol、そしていろんな情報の取り方
- Imfactの使い方と宣伝
- Imfactの設計
